# ARTEMIS SECURITY AUDIT REPORT

**Date**: November 22, 2025 10:56:16 AM
**Project**: Rowan App
**Branch**: main
**Commit**: b0a9c73 (Enforce mandatory workspace onboarding flow)
**Files Changed**: 4 files modified
**Lines of Code**: ~70,000+ LOC (estimated)
**Auditor**: Artemis Code Reviewer
**Audit Type**: Comprehensive Pre-Production Security Review

---

## EXECUTIVE SUMMARY

**Total Issues Found**: 8
- CRITICAL: 2
- HIGH: 3
- MEDIUM: 2
- LOW: 1

**Overall Security Posture**: NEEDS REVISION

**Compliance Status**:
- GDPR: Partial compliance (privacy features present, needs audit trail improvements)
- Security best practices: Generally followed with notable exceptions

**Deployment Recommendation**: ADDRESS CRITICAL ISSUES BEFORE BETA LAUNCH

---

## CRITICAL FINDINGS

### [1] Service Role Key Exposed in Client-Side Service Layer

**Severity**: CRITICAL
**Location**: `/lib/supabase-server.ts:1-24`
**CWE**: CWE-798 (Use of Hard-coded Credentials)
**OWASP**: A07:2021 - Identification and Authentication Failures

**Risk**: The service role key bypasses ALL Row Level Security (RLS) policies. If this client is accidentally imported in a client component, it exposes the service role key to the browser, allowing complete database access.

**Problem**:
The file is named `supabase-server.ts` and contains the service role key, but it's located in `/lib/` which is accessible to both server and client components. The imports in service files use:

```typescript
// lib/services/tasks-service.ts:1
import { createClient } from '@/lib/supabase/client';
```

This is CORRECT (using client SDK), but the existence of `supabaseServer` in `/lib/supabase-server.ts` creates risk.

**Vulnerable Code**:
```typescript
// lib/supabase-server.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

export const supabaseServer = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false,
  },
});
```

**Current Usage**:
- Used correctly in `/app/api/auth/signup/route.ts` (server-side only)
- Used in `/app/api/auth/cleanup-orphaned-user/route.ts` (server-side only)

**Fixed Approach**:
1. Move to `/lib/supabase/admin.ts` or `/lib/server/` directory
2. Add build-time check to prevent client-side imports
3. Use dynamic imports in API routes

```typescript
// lib/supabase/admin.ts (NEW LOCATION)
import { createClient } from '@supabase/supabase-js';

// Runtime check to prevent client-side usage
if (typeof window !== 'undefined') {
  throw new Error('Admin client cannot be used on client side');
}

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  throw new Error('Missing Supabase admin credentials');
}

export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false,
  },
});
```

**Additional Recommendations**:
- Add ESLint rule to prevent `/lib/supabase/admin.ts` imports in client components
- Document in CLAUDE.md that admin client must only be used in API routes
- Consider using Supabase service key rotation policy

**References**:
- [OWASP - Authentication Failures](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/)
- [Supabase RLS Bypass Risks](https://supabase.com/docs/guides/auth/row-level-security#bypassing-row-level-security)

---

### [2] Race Condition in Signup Flow Creates Orphaned Users

**Severity**: CRITICAL (User-Blocking)
**Location**: `/app/api/auth/signup/route.ts:175-257`
**CWE**: CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization)
**OWASP**: A04:2021 - Insecure Design

**Risk**: Users can get stuck in "Finalizing workspace" state if any step in the multi-step signup process fails, creating orphaned auth.users without corresponding public.users or spaces.

**Problem**:
The signup flow has multiple database operations that can fail independently:
1. Create auth.users (via Supabase Auth)
2. Create public.users record
3. Create space
4. Create space_members entry

If step 2, 3, or 4 fails, the user exists in auth.users but has no workspace, causing application deadlock.

**Vulnerable Code**:
```typescript
// app/api/auth/signup/route.ts:175-257
// Step 1: Create auth user (SUCCEEDS)
const { data, error } = await supabase.auth.signUp({ ... });

// Step 2: Create public.users (CAN FAIL - leaves orphaned auth user)
const { error: publicUserError } = await supabaseServerClient
  .from('users')
  .insert({ id: userId, ... });

if (publicUserError) {
  // Cleanup attempt - but what if THIS fails?
  await supabaseServerClient.auth.admin.deleteUser(userId);
  return NextResponse.json({ error: 'Failed to create user profile' }, { status: 500 });
}

// Step 3: Create space (CAN FAIL - leaves orphaned user + public.users)
const { data: newSpace, error: spaceError } = await supabaseServerClient
  .from('spaces')
  .insert({ ... });
```

**Current Mitigation**:
- Cleanup endpoint exists: `/app/api/auth/cleanup-orphaned-user/route.ts`
- Each step attempts to rollback on failure
- BUT: Rollback itself can fail, and there's no transaction guarantee

**Root Cause**:
The fix you just implemented (commit b0a9c73) addresses ONE symptom but not the underlying race condition. The real issue is that Supabase Auth and database operations are not atomic.

**Better Solution - Database Trigger**:
```sql
-- Create function to auto-provision workspace on user creation
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  new_space_id UUID;
BEGIN
  -- Create personal workspace
  INSERT INTO spaces (name, is_personal, auto_created, user_id)
  VALUES (NEW.name || '''s Space', true, true, NEW.id)
  RETURNING id INTO new_space_id;

  -- Add user as owner
  INSERT INTO space_members (space_id, user_id, role)
  VALUES (new_space_id, NEW.id, 'owner');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger on public.users insert
CREATE TRIGGER on_user_created
  AFTER INSERT ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION handle_new_user();
```

**Alternative Solution - Transaction with Savepoints**:
Use Supabase transactions (if available) or implement idempotency:

```typescript
// Idempotent approach
async function ensureUserWorkspace(userId: string, userData: any) {
  // Check if user already has workspace
  const existingSpace = await supabase
    .from('space_members')
    .select('space_id')
    .eq('user_id', userId)
    .single();

  if (existingSpace.data) {
    return existingSpace.data.space_id; // Already provisioned
  }

  // Otherwise, create (this should be in DB trigger)
  // ...
}
```

**Immediate Action Required**:
1. Implement database trigger approach (most reliable)
2. Add idempotency check in signup flow
3. Monitor Sentry for orphaned user errors
4. Create migration to fix existing orphaned users

**Why This Is Critical**:
- Users cannot use the app if stuck in this state
- Creates bad first impression during beta
- Requires manual intervention to resolve
- Already occurred in testing (per context)

**References**:
- [OWASP - Insecure Design](https://owasp.org/Top10/A04_2021-Insecure_Design/)
- [PostgreSQL Triggers](https://www.postgresql.org/docs/current/trigger-definition.html)

---

## HIGH PRIORITY FINDINGS

### [3] Missing Authentication on External Recipe API Route

**Severity**: HIGH
**Location**: `/app/api/recipes/external/search/route.ts:10-69`
**CWE**: CWE-306 (Missing Authentication for Critical Function)
**OWASP**: A01:2021 - Broken Access Control

**Risk**: Unauthenticated users can abuse the recipe search proxy, causing rate limit exhaustion on TheMealDB API and potential service degradation.

**Problem**:
The route has NO authentication or rate limiting checks:

```typescript
// app/api/recipes/external/search/route.ts:10
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q');

    // NO AUTH CHECK HERE!
    // NO RATE LIMITING!

    const response = await fetch(
      `https://www.themealdb.com/api/json/v1/1/search.php?s=${encodeURIComponent(query)}`
    );
    // ...
  }
}
```

**Fixed Code**:
```typescript
import { createClient } from '@/lib/supabase/server';
import { checkGeneralRateLimit } from '@/lib/ratelimit';
import { extractIP } from '@/lib/ratelimit-fallback';

export async function GET(request: NextRequest) {
  try {
    // 1. Rate limiting
    const ip = extractIP(request.headers);
    const { success: rateLimitSuccess } = await checkGeneralRateLimit(ip);

    if (!rateLimitSuccess) {
      return NextResponse.json(
        { error: 'Too many requests. Please try again later.' },
        { status: 429 }
      );
    }

    // 2. Authentication check
    const supabase = createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (authError || !session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 3. Continue with existing logic
    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q');
    // ...
  }
}
```

**Similar Issues Found**:
Check these routes for same vulnerability:
- `/app/api/recipes/external/spoonacular/search/route.ts`
- `/app/api/recipes/external/tasty/search/route.ts`
- `/app/api/recipes/external/apininjas/search/route.ts`
- `/app/api/recipes/external/cuisine/route.ts`

**Impact**:
- API abuse by bots/scrapers
- Rate limit exhaustion on third-party APIs
- Potential cost implications if API keys are metered
- Service degradation for legitimate users

**References**:
- [OWASP - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)

---

### [4] Dependency Vulnerabilities Detected

**Severity**: HIGH
**Location**: `package.json` and `package-lock.json`
**CWE**: CWE-1104 (Use of Unmaintained Third Party Components)

**Risk**: Known security vulnerabilities in dependencies could be exploited.

**Vulnerabilities Found**:
```json
{
  "vulnerabilities": {
    "glob": {
      "severity": "high",
      "via": [{
        "title": "glob CLI: Command injection via -c/--cmd executes matches with shell:true",
        "url": "https://github.com/advisories/GHSA-5j98-mcp5-4vw2",
        "cvss": 7.5,
        "range": ">=11.0.0 <11.1.0"
      }],
      "nodes": ["node_modules/react-email/node_modules/glob"]
    },
    "js-yaml": {
      "severity": "moderate",
      "via": [{
        "title": "js-yaml has prototype pollution in merge (<<)",
        "url": "https://github.com/advisories/GHSA-mh29-5h37-fv8m",
        "cvss": 5.3,
        "range": ">=4.0.0 <4.1.1"
      }],
      "nodes": ["node_modules/js-yaml"]
    }
  }
}
```

**Analysis**:
1. **glob (HIGH - CVSS 7.5)**:
   - Nested dependency from `react-email`
   - Command injection vulnerability
   - Risk: LOW for this app (glob is used for build-time operations, not runtime)
   - Action: Update `react-email` to latest version

2. **js-yaml (MODERATE - CVSS 5.3)**:
   - Prototype pollution vulnerability
   - Risk: LOW-MEDIUM (depends on usage of YAML parsing)
   - Action: Update to js-yaml 4.1.1+

**Fix**:
```bash
# Update dependencies
npm update react-email
npm update js-yaml

# Or force update if needed
npm install react-email@latest
npm install js-yaml@latest

# Verify
npm audit --json
```

**Recommendations**:
- Set up automated dependency scanning in GitHub Actions
- Use Dependabot or Renovate for automatic PR creation
- Run `npm audit` in CI/CD pipeline and fail on HIGH/CRITICAL

**References**:
- [GHSA-5j98-mcp5-4vw2](https://github.com/advisories/GHSA-5j98-mcp5-4vw2)
- [GHSA-mh29-5h37-fv8m](https://github.com/advisories/GHSA-mh29-5h37-fv8m)

---

### [5] CSP Allows 'unsafe-inline' and 'unsafe-eval' in Production

**Severity**: HIGH
**Location**: `/middleware.ts:122-134`
**CWE**: CWE-1021 (Improper Restriction of Rendered UI Layers)
**OWASP**: A05:2021 - Security Misconfiguration

**Risk**: Content Security Policy allows inline scripts and eval, reducing protection against XSS attacks.

**Problem**:
```typescript
// middleware.ts:124
"script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://vercel.live; "
```

The CSP includes `'unsafe-inline'` and `'unsafe-eval'` which defeats much of CSP's XSS protection.

**Why This Exists**:
Next.js and some third-party libraries require these directives to function.

**Better Approach - Use Nonces**:
```typescript
// middleware.ts (improved)
import { randomBytes } from 'crypto';

export async function middleware(req: NextRequest) {
  // Generate nonce for this request
  const nonce = randomBytes(16).toString('base64');

  let response = NextResponse.next({
    request: {
      headers: new Headers({
        ...req.headers,
        'x-nonce': nonce, // Pass to pages
      }),
    },
  });

  // Use nonce-based CSP
  response.headers.set(
    'Content-Security-Policy',
    `default-src 'self'; ` +
    `script-src 'self' 'nonce-${nonce}' https://cdn.jsdelivr.net https://vercel.live; ` +
    `style-src 'self' 'nonce-${nonce}' https://cdn.jsdelivr.net; ` +
    // ... rest of CSP
  );

  return response;
}
```

Then in your React components:
```tsx
// Get nonce from headers and inject into scripts
<Script nonce={nonce} src="..." />
```

**Alternative - Hash-based CSP**:
For static scripts, use hashes instead of `unsafe-inline`:
```typescript
"script-src 'self' 'sha256-[hash-of-your-script]' https://cdn.jsdelivr.net;"
```

**Immediate Action**:
1. Audit which dependencies require `unsafe-inline`/`unsafe-eval`
2. Consider using nonce-based CSP for Next.js 14
3. At minimum, remove `unsafe-eval` if not strictly necessary
4. Add `strict-dynamic` for modern browsers

**References**:
- [OWASP - CSP Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)
- [Next.js CSP Configuration](https://nextjs.org/docs/app/building-your-application/configuring/content-security-policy)

---

## MEDIUM PRIORITY FINDINGS

### [6] Missing Input Sanitization in Signup Flow

**Severity**: MEDIUM
**Location**: `/app/api/auth/signup/route.ts:99-106`
**CWE**: CWE-79 (Improper Neutralization of Input During Web Page Generation)

**Problem**:
The signup route uses basic tag stripping instead of proper HTML sanitization:

```typescript
// app/api/auth/signup/route.ts:100
const stripTags = (str: string) => str.replace(/<[^>]*>/g, '').trim();

const sanitizedProfile = {
  ...validated.profile,
  name: stripTags(validated.profile.name),
  space_name: validated.profile.space_name ? stripTags(validated.profile.space_name) : undefined,
};
```

**Risk**: MEDIUM (Zod validation limits characters, reducing XSS risk, but improper sanitization)

**Better Approach**:
```typescript
import DOMPurify from 'isomorphic-dompurify';

const sanitizedProfile = {
  ...validated.profile,
  name: DOMPurify.sanitize(validated.profile.name, { ALLOWED_TAGS: [] }),
  space_name: validated.profile.space_name
    ? DOMPurify.sanitize(validated.profile.space_name, { ALLOWED_TAGS: [] })
    : undefined,
};
```

**Note**:
DOMPurify is already in dependencies (`"dompurify": "^3.3.0"`), so no new package needed.

**Why Not CRITICAL**:
- Zod validation limits input to 100 chars
- Data is stored in database (not immediately reflected in HTML)
- React escapes by default when rendering
- BUT: Better safe than sorry

**Recommendation**:
Replace all manual tag stripping with DOMPurify across the codebase.

---

### [7] CRON_SECRET and INTERNAL_API_SECRET Validation Inconsistency

**Severity**: MEDIUM
**Location**: Multiple cron and internal API routes
**CWE**: CWE-287 (Improper Authentication)

**Problem**:
Different routes use inconsistent secret validation patterns:

**Pattern 1 - Direct comparison** (VULNERABLE to timing attacks):
```typescript
// app/api/cron/cleanup-deleted-accounts/route.ts:52
const cronSecret = process.env.CRON_SECRET;
if (authHeader !== `Bearer ${cronSecret}`) {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
}
```

**Pattern 2 - No timing-safe comparison anywhere**

**Fixed Code**:
```typescript
import { timingSafeEqual } from 'crypto';

function validateSecret(provided: string | null, expected: string): boolean {
  if (!provided || !expected) return false;

  // Ensure same length to prevent timing attacks
  if (provided.length !== expected.length) return false;

  try {
    return timingSafeEqual(
      Buffer.from(provided),
      Buffer.from(expected)
    );
  } catch {
    return false;
  }
}

// Usage
const authHeader = req.headers.get('authorization');
const expectedSecret = `Bearer ${process.env.CRON_SECRET}`;

if (!validateSecret(authHeader, expectedSecret)) {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
}
```

**Why This Matters**:
Timing attacks can reveal secret values character-by-character by measuring response times.

**Files to Update**:
- `/app/api/cron/goal-checkin-notifications/route.ts`
- `/app/api/cron/process-deletions/route.ts`
- `/app/api/cron/process-notifications/route.ts`
- `/app/api/cron/reminder-notifications/route.ts`
- `/app/api/cron/cleanup-deleted-accounts/route.ts`
- `/app/api/cron/task-jobs/route.ts`
- `/app/api/privacy/generate-export/route.ts`

**Recommendation**:
Create a shared utility function in `/lib/auth/timing-safe-compare.ts` and use it consistently.

---

## LOW PRIORITY FINDINGS

### [8] TypeScript Build Warnings for Type Definitions

**Severity**: LOW
**Location**: `tsconfig.json` configuration
**CWE**: N/A (Code Quality)

**Problem**:
TypeScript compilation shows warnings about missing type definitions:

```
error TS2688: Cannot find type definition file for 'canvas-confetti 2'.
error TS2688: Cannot find type definition file for 'connect 2'.
error TS2688: Cannot find type definition file for 'cors 2'.
```

**Root Cause**:
Appears to be a duplicate `.next 2` directory causing type resolution issues:
```
drwx------     3 airborneshellback  staff      96 Oct 12 16:20 .next 2
```

**Fix**:
```bash
# Remove duplicate directory
rm -rf ".next 2"

# Clean build artifacts
rm -rf .next tsconfig.tsbuildinfo

# Rebuild
npm run build
```

**Impact**: LOW - Does not affect runtime security, only development experience

---

## SECURITY CHECKLIST RESULTS

### Authentication & Authorization
- PASS: Password validation (min 8 chars, uppercase, lowercase, number)
- PASS: Rate limiting on auth endpoints (3 attempts/hour signup, 5/hour login)
- PASS: No hardcoded credentials found in code
- PASS: Session management via Supabase (secure cookies)
- FAIL: Service role key in accessible location
- PASS: CSRF protection in middleware
- PASS: Authorization checks on API routes (`verifySpaceAccess`)
- WARN: Signup flow race condition creates orphaned users

**Score**: 6/8 (75%)

### Input Validation & Sanitization
- PASS: Zod validation on all API routes
- PASS: Parameterized queries (Supabase client, no raw SQL)
- PASS: No SQL injection vulnerabilities found
- PASS: No command injection (no eval, exec, system calls)
- WARN: Basic tag stripping instead of DOMPurify in signup
- PASS: API input validation with Zod schemas
- PASS: No dangerouslySetInnerHTML found
- PASS: Path traversal prevention (no file uploads with user paths)

**Score**: 7/8 (87.5%)

### Data Protection
- PASS: No sensitive data in logs (error messages sanitized)
- PASS: TLS enforced via Vercel (automatic HTTPS)
- PASS: Environment variables properly segregated (NEXT_PUBLIC_ vs server-only)
- PASS: No PII in client-side code
- PASS: Cryptographically secure tokens (crypto.randomUUID())
- PASS: Secure cookie attributes (httpOnly via Supabase)
- PASS: Database credentials in environment variables
- PASS: No secrets in git (.env.local in .gitignore)

**Score**: 8/8 (100%)

### API Security
- PASS: Rate limiting on API routes (Upstash Redis + fallback)
- PASS: Proper CORS configuration (same-origin)
- PASS: Error handling (generic errors to users, detailed logs)
- PASS: Content-type validation
- FAIL: Missing auth on external recipe proxy routes
- PASS: Request size limits (Next.js default)
- PASS: No API keys in client code

**Score**: 6/7 (85.7%)

### Database Security
- PASS: RLS enabled on all tables
- PASS: All queries filtered by space_id
- PASS: RLS policies enforce data isolation
- PASS: Foreign key constraints in place
- PASS: user_has_space_access() helper function
- PASS: Nested relationship policies (messages inherit from conversations)
- PASS: Database migration safety (all migrations tracked)
- WARN: Signup race condition (user creation not atomic)

**Score**: 7/8 (87.5%)

### Frontend Security
- PASS: No sensitive tokens in localStorage
- PASS: Server vs Client Component boundaries respected
- PASS: No secrets in Client Components
- PASS: NEXT_PUBLIC_ variables contain no secrets (verified)
- PASS: No XSS via dangerouslySetInnerHTML
- PASS: React auto-escaping for user content

**Score**: 6/6 (100%)

### Infrastructure & Headers
- PASS: CSP header present
- WARN: CSP allows 'unsafe-inline' and 'unsafe-eval'
- PASS: HSTS header (max-age=31536000)
- PASS: X-Frame-Options: DENY
- PASS: X-Content-Type-Options: nosniff
- PASS: Referrer-Policy: strict-origin-when-cross-origin
- PASS: Permissions-Policy configured

**Score**: 6/7 (85.7%)

---

## CODE QUALITY ASSESSMENT

### Architecture
- **SOLID Principles**: Well-followed
  - Service layer pattern consistently used
  - Single responsibility in service functions
  - Dependency injection via createClient()
- **Separation of Concerns**: Excellent
  - `/lib/services/` for business logic
  - `/app/api/` for API routes
  - `/lib/schemas/` for validation
- **Design Patterns**: Repository pattern, service layer, middleware chain

**Grade**: A

### Error Handling
- **Try/Catch**: Present in all async operations
- **Specific Errors**: Zod validation errors properly formatted
- **Logging**: Sentry integration for error tracking
- **Cleanup**: Proper cleanup in signup rollback (though not atomic)
- **Generic Errors**: User-facing errors are generic, detailed logs server-side

**Grade**: A-

### Performance
- **N+1 Queries**: Not observed (using .select() with filters)
- **Indexes**: Comprehensive indexes on space_id, user_id
- **Caching**: Redis for rate limiting
- **Pagination**: Implemented in services
- **Real-time**: Proper cleanup of Supabase subscriptions

**Grade**: A

### Testing
- **Unit Tests**: Not found in repository
- **Integration Tests**: Not found
- **Security Tests**: None automated
- **Coverage**: Unknown

**Grade**: F (MAJOR GAP)

### Maintainability
- **Code Documentation**: Service functions well-documented with JSDoc
- **Naming Conventions**: Consistent (camelCase, PascalCase, UPPER_SNAKE_CASE)
- **Type Safety**: TypeScript strict mode enabled
- **TODOs**: Some present in documentation files
- **Complexity**: Functions are appropriately sized (<100 lines)

**Grade**: B+

---

## POSITIVE OBSERVATIONS

1. **Comprehensive RLS Policies**: All tables have proper row-level security policies that enforce space-based data isolation. The `user_has_space_access()` helper function is well-designed.

2. **Robust Rate Limiting**: Dual-tier rate limiting (Redis + in-memory fallback) ensures protection even if Redis fails. Different limits for auth vs general API.

3. **Security Headers**: Production middleware includes comprehensive security headers (CSP, HSTS, X-Frame-Options, etc.).

4. **Input Validation**: Zod schemas are used consistently across API routes, with proper error formatting.

5. **No Sensitive Data Exposure**: Environment variables are properly segregated (NEXT_PUBLIC_ vs server-only). No credentials found in code.

6. **Service Layer Pattern**: Clean architecture with separation between API routes and business logic.

7. **Sentry Integration**: Error tracking and monitoring properly configured.

8. **Authorization Checks**: `verifySpaceAccess()` is called before sensitive operations.

9. **CSRF Protection**: Middleware validates Origin header for state-changing requests.

10. **Proper Supabase Client Usage**: Services use client SDK (not service role), API routes use server SDK appropriately.

---

## RECOMMENDATIONS

### Immediate Actions (< 24 hours)

1. **FIX CRITICAL #1**: Move `supabaseServer` to `/lib/supabase/admin.ts` with client-side guard
   ```bash
   mv lib/supabase-server.ts lib/supabase/admin.ts
   # Update imports in signup/route.ts and cleanup-orphaned-user/route.ts
   ```

2. **FIX CRITICAL #2**: Implement database trigger for workspace auto-provisioning
   ```sql
   -- See SQL in Critical Finding #2
   ```

3. **FIX HIGH #3**: Add auth + rate limiting to external recipe proxy routes
   ```typescript
   // Apply to all /app/api/recipes/external/*/route.ts files
   ```

4. **FIX HIGH #4**: Update dependencies
   ```bash
   npm update react-email js-yaml
   npm audit fix
   ```

### Short-term (< 1 week)

5. **FIX HIGH #5**: Implement nonce-based CSP or remove unsafe-eval
   - Research if unsafe-eval is truly needed
   - Implement nonce generation in middleware

6. **FIX MEDIUM #6**: Replace tag stripping with DOMPurify
   ```typescript
   import DOMPurify from 'isomorphic-dompurify';
   ```

7. **FIX MEDIUM #7**: Implement timing-safe secret comparison
   - Create utility function
   - Update all cron routes

8. **FIX LOW #8**: Clean duplicate .next directory
   ```bash
   rm -rf ".next 2"
   ```

9. **Add Automated Testing**:
   - Security tests for auth flows
   - Integration tests for signup race condition
   - Unit tests for critical services

10. **Dependency Scanning in CI**:
    - Add `npm audit` to GitHub Actions
    - Set up Dependabot

### Long-term (< 1 month)

11. **Implement Comprehensive Logging**:
    - Audit trail for all data modifications
    - GDPR-compliant user action logs
    - Security event monitoring (failed logins, privilege escalation attempts)

12. **Penetration Testing**:
    - Conduct manual penetration test
    - Test IDOR (Insecure Direct Object Reference) vulnerabilities
    - Test space boundary enforcement

13. **Security Training**:
    - Document common vulnerabilities for team
    - Create secure coding guidelines specific to this stack

14. **Monitoring & Alerting**:
    - Set up alerts for unusual auth patterns
    - Monitor rate limit violations
    - Track orphaned user creation in Sentry

15. **Performance Optimization**:
    - Add database query performance monitoring
    - Implement caching strategy for read-heavy operations

---

## COMPARISON WITH PREVIOUS AUDITS

Based on security audit files found in repository:
- `security-audit-2025-10-14.md` (Oct 14)
- `SECURITY_AUDIT_REPORT.md` (Oct 12)
- `AUDIT_SUMMARY.md` (Oct 12)

**Issues Resolved Since Last Audit**:
- CSRF protection implemented in middleware
- Rate limiting added with Redis + fallback
- RLS policies comprehensively applied
- Input validation with Zod across all routes
- Security headers in production

**New Issues Introduced**:
- Signup race condition (from recent workspace changes)
- Missing auth on recipe proxy (new feature)

**Recurring Issues**:
- Dependency vulnerabilities (ongoing maintenance needed)
- CSP unsafe-inline (not yet resolved)

**Overall Trend**: IMPROVING

Previous audits identified foundational security issues that have been addressed. Current issues are more nuanced (race conditions, CSP tuning) indicating maturation of security practices.

---

## AUTOMATED SCAN RESULTS

### Dependency Vulnerabilities
```json
{
  "vulnerabilities": {
    "total": 2,
    "high": 1,
    "moderate": 1
  }
}
```
See HIGH FINDING #4 for details.

### Static Analysis
**No dangerous patterns found**:
- No `eval()` usage
- No `Function()` constructor
- No `setTimeout(string)` or `setInterval(string)`
- No `dangerouslySetInnerHTML`

### Secret Scanning
**No hardcoded secrets detected** in codebase (excluding .env files)

---

## CONCLUSION

**Must Fix Before Deployment**: YES

**Overall Status**: NEEDS REVISION

**Critical Blockers**:
1. Service role key location risk
2. Signup race condition (user-blocking)
3. Missing auth on recipe proxy

**Deployment Risk Level**: MEDIUM-HIGH

The Rowan application demonstrates strong security fundamentals with comprehensive RLS policies, proper input validation, and good architectural patterns. However, the two critical issues (service role exposure risk and signup race condition) must be addressed before beta launch.

The signup race condition is particularly concerning as it directly impacts user onboarding - the most critical path in your beta testing phase. Users who encounter this will have no way to use the application.

**Recommendation**:
1. Fix Critical #1 and #2 immediately (estimated 4-6 hours)
2. Fix High #3 and #4 (estimated 2-3 hours)
3. Then proceed with beta deployment
4. Address Medium/Low issues during beta period

**Next Audit Recommended**: After beta launch (2 weeks) to assess real-world security posture.

---

**Audited by**: Artemis Code Reviewer
**Report Generated**: November 22, 2025 10:56:16 AM
**Audit Duration**: ~45 minutes
**Files Analyzed**: 100+ (focused on security-critical paths)
