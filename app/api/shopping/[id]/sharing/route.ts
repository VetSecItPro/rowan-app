import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { checkGeneralRateLimit } from '@/lib/ratelimit';
import { verifyResourceAccess } from '@/lib/services/authorization-service';
import * as Sentry from '@sentry/nextjs';
import { setSentryUser } from '@/lib/sentry-utils';
import { extractIP } from '@/lib/ratelimit-fallback';

/**
 * PATCH /api/shopping/[id]/sharing
 * Update sharing settings for a shopping list (make public/private)
 */
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Rate limiting
    const ip = extractIP(req.headers);
    const { success: rateLimitSuccess } = await checkGeneralRateLimit(ip);

    if (!rateLimitSuccess) {
      return NextResponse.json(
        { error: 'Too many requests. Please try again later.' },
        { status: 429 }
      );
    }

    // Verify authentication
    const supabase = createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (authError || !session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Set user context for Sentry error tracking
    setSentryUser(session.user);

    // Parse request body
    const body = await req.json();
    const { isPublic } = body;

    // Validate input
    if (typeof isPublic !== 'boolean') {
      return NextResponse.json(
        { error: 'isPublic must be a boolean value' },
        { status: 400 }
      );
    }

    const listId = params.id;

    // Get existing list first to verify access
    const { data: existingList, error: fetchError } = await supabase
      .from('shopping_lists')
      .select('*')
      .eq('id', listId)
      .single();

    if (fetchError || !existingList) {
      return NextResponse.json(
        { error: 'Shopping list not found' },
        { status: 404 }
      );
    }

    // Verify user has access to list's space
    try {
      await verifyResourceAccess(session.user.id, existingList);
    } catch (error) {
      Sentry.captureException(error, {
        tags: {
          endpoint: '/api/shopping/[id]/sharing',
          method: 'PATCH',
        },
        extra: {
          listId,
          userId: session.user.id,
          timestamp: new Date().toISOString(),
        },
      });

      return NextResponse.json(
        { error: 'You do not have access to this shopping list' },
        { status: 403 }
      );
    }

    // Prepare update data
    const updateData: any = {
      is_public: isPublic,
      updated_at: new Date().toISOString(),
    };

    // If making public, ensure we have a secure share token
    // The database trigger will automatically generate a secure token
    // when is_public becomes true, but we can also explicitly set one
    if (isPublic && !existingList.share_token) {
      // Let the database trigger handle token generation for consistency
      // The secure token will be generated by our database function
    }

    // If making private, we could optionally regenerate token for extra security
    if (!isPublic) {
      // Keep the existing token for now to avoid breaking existing links
      // Users could manually regenerate if needed
      updateData.shared_at = null;
    }

    // Update the shopping list
    // The database trigger will handle secure token generation automatically
    const { data: updatedList, error: updateError } = await supabase
      .from('shopping_lists')
      .update(updateData)
      .eq('id', listId)
      .select('*')
      .single();

    if (updateError) {
      throw updateError;
    }

    // Log the sharing action for security monitoring
    console.log(`Shopping list sharing updated: ${listId} -> ${isPublic ? 'public' : 'private'} by user ${session.user.id} from IP ${ip}`);

    // Prepare response data
    const responseData = {
      ...updatedList,
      shareUrl: isPublic && updatedList.share_token
        ? `${process.env.NEXT_PUBLIC_APP_URL || ''}/shopping/share/${updatedList.share_token}`
        : null,
    };

    return NextResponse.json({
      success: true,
      data: responseData,
      message: isPublic ? 'List is now public and shareable' : 'List is now private',
    });

  } catch (error) {
    Sentry.captureException(error, {
      tags: {
        endpoint: '/api/shopping/[id]/sharing',
        method: 'PATCH',
      },
      extra: {
        timestamp: new Date().toISOString(),
      },
    });
    console.error('[API] /api/shopping/[id]/sharing PATCH error:', error);
    return NextResponse.json(
      { error: 'Failed to update sharing settings' },
      { status: 500 }
    );
  }
}

/**
 * GET /api/shopping/[id]/sharing
 * Get current sharing status and link for a shopping list
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Rate limiting
    const ip = extractIP(req.headers);
    const { success: rateLimitSuccess } = await checkGeneralRateLimit(ip);

    if (!rateLimitSuccess) {
      return NextResponse.json(
        { error: 'Too many requests. Please try again later.' },
        { status: 429 }
      );
    }

    // Verify authentication
    const supabase = createClient();
    const { data: { session }, error: authError } = await supabase.auth.getSession();

    if (authError || !session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    setSentryUser(session.user);

    const listId = params.id;

    // Get list with sharing info
    const { data: list, error: fetchError } = await supabase
      .from('shopping_lists')
      .select('id, title, is_public, share_token, shared_at, space_id')
      .eq('id', listId)
      .single();

    if (fetchError || !list) {
      return NextResponse.json(
        { error: 'Shopping list not found' },
        { status: 404 }
      );
    }

    // Verify user has access to list's space
    try {
      await verifyResourceAccess(session.user.id, list);
    } catch (error) {
      return NextResponse.json(
        { error: 'You do not have access to this shopping list' },
        { status: 403 }
      );
    }

    // Prepare response
    const sharingInfo = {
      id: list.id,
      title: list.title,
      isPublic: list.is_public || false,
      sharedAt: list.shared_at,
      shareUrl: list.is_public && list.share_token
        ? `${process.env.NEXT_PUBLIC_APP_URL || ''}/shopping/share/${list.share_token}`
        : null,
    };

    return NextResponse.json({
      success: true,
      data: sharingInfo,
    });

  } catch (error) {
    Sentry.captureException(error, {
      tags: {
        endpoint: '/api/shopping/[id]/sharing',
        method: 'GET',
      },
      extra: {
        timestamp: new Date().toISOString(),
      },
    });
    console.error('[API] /api/shopping/[id]/sharing GET error:', error);
    return NextResponse.json(
      { error: 'Failed to get sharing information' },
      { status: 500 }
    );
  }
}